using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Generator.Metadata.CopyCode;

[Generator]
internal sealed class CopyCodeGenerator : IIncrementalGenerator
{
    private const string CopyAttribute = """
        // <auto-generated/>
        #nullable enable

        namespace Generator.Metadata.CopyCode
        {
        	[global::System.AttributeUsage(global::System.AttributeTargets.Enum | global::System.AttributeTargets.Class | global::System.AttributeTargets.Struct | global::System.AttributeTargets.Interface, AllowMultiple = false)]
        	internal sealed class CopyAttribute : global::System.Attribute
        	{
        	}
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        const string copyAttribute = "Generator.Metadata.CopyCode.CopyAttribute";

        context.RegisterPostInitializationOutput(PostInitializationCallback);

        var provider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                copyAttribute,
                SyntaxProviderPredicate,
                SyntaxProviderTransform
            )
            .Where(static method => method != default);

        context.RegisterSourceOutput(provider, SourceOutputAction);
    }

    private static void PostInitializationCallback(
        IncrementalGeneratorPostInitializationContext context
    )
    {
        context.AddSource(
            "Generator.Metadata.CopyCode.CopyAttribute.g.cs",
            SourceText.From(CopyAttribute, Encoding.UTF8)
        );
    }

    private static bool SyntaxProviderPredicate(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken
    )
    {
        return syntaxNode is BaseTypeDeclarationSyntax;
    }

    private static (string name, string code) SyntaxProviderTransform(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken
    )
    {
        var syntaxNode = CreateTypeCopy((BaseTypeDeclarationSyntax)context.TargetNode);

        // We need the symbol to get the namespace, using parent syntax could not work with FileScopedNamespaceDeclaration
        INamedTypeSymbol symbol = (INamedTypeSymbol)context.TargetSymbol;

        string? @namespace;
        {
            StringBuilder builder = new StringBuilder();
            var currentNameSpace = symbol.ContainingNamespace;
            if (!currentNameSpace.IsGlobalNamespace)
            {
                while (currentNameSpace is not null)
                {
                    var ns = currentNameSpace.IsGlobalNamespace ? "" : currentNameSpace.Name;
                    if (builder.Length != 0 && !currentNameSpace.IsGlobalNamespace)
                    {
                        builder.Insert(0, '.');
                    }

                    builder.Insert(0, ns);
                    currentNameSpace = currentNameSpace.ContainingNamespace;
                }
            }

            @namespace = builder.ToString();
        }

        List<ParentClass> parents = syntaxNode.Parent is TypeDeclarationSyntax typeDeclarationSyntax
            ? ParentClass.GetParentClasses(typeDeclarationSyntax)
            : [];

        StringBuilder stringBuilder = new();
        using StringWriter writer = new(stringBuilder, CultureInfo.InvariantCulture);
        using IndentedTextWriter source = new(writer, "    ");

        var textToCopy = syntaxNode.NormalizeWhitespace().ToFullString();

        var maximumNumberOfQuotas = Regex
            .Matches(textToCopy, "\"\"(\")+")
            .OfType<Match>()
            .Select(x => x.Length)
            .Concat(new[] { 2 })
            .Max();

        var quotation = new string('"', maximumNumberOfQuotas + 1);

        source.WriteLine("// <auto-generated/>");
        source.WriteLine("#nullable enable");
        source.WriteLine("namespace Generator.Metadata.CopyCode;");

        source.WriteLine("internal static partial class Copy {");
        source.Indent++;

        source.WriteLine(
            $"public const string {symbol.ToDisplayString().Replace(".", "")} = {quotation}"
        );
        source.Indent++;

        source.WriteLine("// <auto-generated/>");
        source.WriteLine("#nullable enable");
        source.WriteLine("using System;");

        source.WriteLine();

        if (@namespace.Length > 0)
        {
            source.WriteLine($"namespace {@namespace};");
        }

        foreach (var type in parents)
        {
            source.WriteLine(
                $"partial {type.Keyword} {type.Name} {type.Constraints}{(type.Constraints.Length > 0 ? " " : "")}{{"
            );
            source.Indent++;
        }

        // We want to copy only the Attributes below the copy Attribute
        var attributesToSkip =
            syntaxNode
                .AttributeLists.TakeWhile(list =>
                    list.Attributes.All(x =>
                        x
                        != (SyntaxNode?)
                            context.Attributes.First().ApplicationSyntaxReference!.GetSyntax()
                    )
                )
                .Count() + 1;

        // Full qualify the name
        var newAttributeList = new SyntaxList<AttributeListSyntax>(
            syntaxNode.AttributeLists.Select(x =>
                x.WithAttributes(
                    new SeparatedSyntaxList<AttributeSyntax>().AddRange(
                        x.Attributes.Select(attributeConstructor =>
                        {
                            var sym = context
                                .SemanticModel.GetSymbolInfo(attributeConstructor)
                                .Symbol;
                            if (
                                sym is IMethodSymbol method
                                && method.ContainingSymbol is INamedTypeSymbol namedSymbol
                            )
                            {
                                var newfull = namedSymbol.ToDisplayString(
                                    SymbolDisplayFormat.FullyQualifiedFormat
                                );
                                attributeConstructor = attributeConstructor.WithName(
                                    SyntaxFactory.ParseName(newfull)
                                );
                            }

                            return attributeConstructor;
                        })
                    )
                )
            )
        );

        for (int i = 0; i < attributesToSkip; i++)
        {
            newAttributeList = newAttributeList.RemoveAt(0);
        }

        var syntaxToPrint = syntaxNode.WithAttributeLists(newAttributeList);

        // Write single lines so identation works
        var splitter = syntaxToPrint
            .NormalizeWhitespace(indentation: "    ", eol: "\n")
            .ToString()
            .AsSpan()
            .Split('\n');

        foreach (var item in splitter)
        {
            source.WriteLine(item.ToString());
        }

        for (int i = 0; i < parents.Count; i++)
        {
            source.Indent--;
            source.WriteLine("}");
        }

        source.WriteLine($"{quotation};");
        source.Indent--;
        source.Indent--;
        source.WriteLine("}");

        return (symbol.ToDisplayString(), stringBuilder.ToString());
    }

    private static void SourceOutputAction(
        SourceProductionContext context,
        (string name, string code) data
    )
    {
        context.AddSource($"{data.name}.Copy.g.cs", data.code);
    }

    private static BaseTypeDeclarationSyntax CreateTypeCopy(BaseTypeDeclarationSyntax originalType)
    {
        // Handle different type declarations and ensure all parts are copied
        return originalType switch
        {
            ClassDeclarationSyntax classDeclaration
                => classDeclaration
                    .WithTypeParameterList(classDeclaration.TypeParameterList)
                    .WithConstraintClauses(classDeclaration.ConstraintClauses)
                    .WithMembers(classDeclaration.Members)
                    .WithModifiers(classDeclaration.Modifiers),
            StructDeclarationSyntax structDeclaration
                => structDeclaration
                    .WithTypeParameterList(structDeclaration.TypeParameterList)
                    .WithConstraintClauses(structDeclaration.ConstraintClauses)
                    .WithMembers(structDeclaration.Members)
                    .WithModifiers(structDeclaration.Modifiers),
            InterfaceDeclarationSyntax interfaceDeclaration
                => interfaceDeclaration
                    .WithTypeParameterList(interfaceDeclaration.TypeParameterList)
                    .WithConstraintClauses(interfaceDeclaration.ConstraintClauses)
                    .WithMembers(interfaceDeclaration.Members)
                    .WithModifiers(interfaceDeclaration.Modifiers),
            RecordDeclarationSyntax recordDeclaration
                => recordDeclaration
                    .WithTypeParameterList(recordDeclaration.TypeParameterList)
                    .WithConstraintClauses(recordDeclaration.ConstraintClauses)
                    .WithMembers(recordDeclaration.Members)
                    .WithModifiers(recordDeclaration.Modifiers),
            _ => throw new NotSupportedException("Unsupported type declaration.")
        };
    }
}

internal class ParentClass
{
    public ParentClass(string keyword, string name, string constraints)
    {
        Keyword = keyword;
        Name = name;
        Constraints = constraints;
    }

    public string Keyword { get; }
    public string Name { get; }
    public string Constraints { get; }

    public static List<ParentClass> GetParentClasses(TypeDeclarationSyntax typeSyntax)
    {
        var list = new List<ParentClass>();
        GetParentClassesInternal(typeSyntax, list);
        return list;
    }

    private static void GetParentClassesInternal(
        TypeDeclarationSyntax typeSyntax,
        List<ParentClass> list
    )
    {
        TypeDeclarationSyntax? parentSyntax = typeSyntax;

        while (parentSyntax != null && IsAllowedKind(parentSyntax.Kind()))
        {
            var parentClassInfo = new ParentClass(
                keyword: parentSyntax.Keyword.ValueText,
                name: parentSyntax.Identifier.ToString() + parentSyntax.TypeParameterList,
                constraints: parentSyntax.ConstraintClauses.ToString()
            );

            parentSyntax = parentSyntax.Parent as TypeDeclarationSyntax;
            list.Add(parentClassInfo);
        }
    }

    private static bool IsAllowedKind(SyntaxKind kind) =>
        kind
            is SyntaxKind.ClassDeclaration
                or SyntaxKind.InterfaceDeclaration
                or SyntaxKind.StructDeclaration
                or SyntaxKind.RecordDeclaration;
}
